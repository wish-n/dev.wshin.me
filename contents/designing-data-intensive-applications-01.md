---
title: 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
date: 2024-11-03 23:17:00
draft: false
---

> **요약하면...**
> 
> - 애플리케이션의 세 가지 설계 원칙 : 신뢰성, 확장성, 유지보수성
> - 신뢰성 : 결함이 발생해도 시스템이 올바르게 동작해야 한다.
> - 확장성 : 부하가 증가해도 좋은 성능을 유지하기 위해 확장할 수 있어야 한다.
> - 유지보수성 : 엔지니어와 운영팀이 생산적으로 작업할 수 있어야 한다.

CPU 성능보다도 데이터의 양, 복잡도, 변화 속도가 애플리케이션 개발에 중요한 요소가 되었다. (데이터 중심적)

데이터베이스, 캐시 등 이미 잘 추상화된 데이터 시스템이 있지만, 저마다 다른 특성을 가지고 있기에 **어떤 시스템과 방식이 애플리케이션 요구사항에 적합한지** 생각해야 한다.

또한 단일 시스템으로는 애플리케이션 요구사항을 충족시키지 못해, 여러 시스템을 애플리케이션 코드로 결합한 복합 데이터 시스템을 설계하는 경우가 많다. 즉 애플리케이션 개발자는 데이터 시스템 설계자이기도 하며, 대부분의 소프트웨어 시스템에서 중요한 관심사인 **신뢰성, 확장성, 유지보수성**에 대해 생각해야 한다.

### 신뢰성

> 하드웨어나 소프트웨어 결함, 또는 휴먼 에러 같은 문제가 발생했을 때도 원하는 수준에서 정확한 기능을 수행해야 한다.

하드웨어나 소프트웨어 결함, 또는 휴먼 에러를 예측하고 대처할 수 있는 **내결함성** 시스템을 설계하여 결함이 장애로 이어지는 것을 방지한다.

#### 하드웨어 결함

디스크, 서버 컴퓨터, 전원 등의 **하드웨어 구성 요소의 중복**으로 대응하는 것이 일반적이다.
- 예를 들어 디스크 RAID 구성, 서버 이중 전원 및 Hot-swap CPU, 데이터센터의 예비 전원 등
- (맥락상 여기서 말하는 하드웨어 구성 요소 중복이란, 서버의 Scale-out이 아니라 Active-Standby 구조의 단일 서버 운영에 가까움)

하지만 최근에는 하드웨어 구성 요소 중복뿐만 아니라 **소프트웨어 내결함성 기술**을 사용하는 추세.
- 더 많은 장비를 사용하게 되면서 장비 결함이 증가했고, AWS 같은 클라우드 플랫폼은 가상 인스턴스가 죽는 일이 일반적이기 때문
- OS 패치 등 장비를 재부팅해야 하는 경우 단일 장비와 다르게 롤링 업그레이드로 무중단 작업이 가능하다는 점도 장점

#### 소프트웨어 결함

특정 상황이 발생하기 전까지 오랫동안 나타나지 않는다. 소프트웨어는 환경에 대한 일종의 가정들을 기반으로 동작하지만, 이 가정이 사실이 아니게 되는 상황에 의해 결함이 발생한다.
- 잘못된 특정 입력이 있을 때 애플리케이션 인스턴스가 죽는 소프트웨어 버그
- CPU, 메모리, 디스크와 네트워크 대역폭 등의 공유 자원을 과도하게 사용하는 일부 프로세스
- 시스템 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
- 연쇄 장애 (한 구성 요소의 결함이 다른 구성 요소의 결함을 야기하여 차례차례 더 많은 결함이 발생)

소프트웨어 결함은 신속한 해결책이 없으며, 다양한 작업들이 문제 해결에 도움을 줄 수 있다.
- 시스템의 가정 및 상호작용에 대해 주의 깊게 생각하기
- 빈틈없는 테스트
- 프로세스 격리
- 죽은 프로세스의 재시작 허용
- 프로덕션 환경에서의 동작 측정
- 모니터링 및 분석
- 애플리케이션 수행 중 기대되지 않은 동작이 발생할 경우 경고 발생시키기

#### 휴먼 에러

서비스 중단의 주요 원인은 하드웨어 결함보다는 운영자의 설정 오류이다. 다양한 접근 방식을 결합해 휴먼 에러에 대한 신뢰성을 높일 수 있다.

- 오류의 가능성을 최소화하는 방향으로 시스템 설계하기
	- e.g. **좋은 추상화 설계**를 사용하면 옳은 일은 쉽게 하고 잘못된 일은 방지할 수 있음
- 가장 많이 실수하는 부분에서 **사람의 실수로 장애가 발생할 수 있는 부분을 분리**하기
	- e.g. 실제 데이터를 사용하지만 실제 사용자에게는 영향을 주지 않는 비 프로덕션 샌드박스 제공
- 단위 테스트, 통합 테스트, 수동 테스트까지 모든 수준에서 **철저하게 테스트하기**
	- 특히 자동 테스트는 코너 케이스를 다루는 데 유용함
- **빠르게 쉽게 복구할 수 있는 방법 마련**하기
	- 롤백 방법을 마련하고 이전 계산이 잘못된 경우를 대비해 데이터 재계산 도구를 제공
- 성능 지표와 오류율 등 **상세하고 명확한 모니터링 도구 마련**하기
	- 조기에 경고 신호를 보내줄 수 있고, 특정 가정 및 제한을 벗어나는지 확인할 수 있게 함
	- 문제가 발생했을 때 문제 분석을 위해 지표를 제공함
- 조직 교육과 실습

### 확장성

> 데이터 규모, 트래픽 규모, 그리고 복잡도가 증가했을 때 이를 처리할 수 있는 적절한 방법이 있어야 한다.

현재 안정적으로 동작하는 시스템이더라도, 동시 사용자가 늘어나거나 처리해야 하는 데이터가 늘어나는 등 부하가 증가하는 경우 안정적으로 동작하지 않을 수 있다. 추가 부하를 어떻게 대처할 것인지, 계산 자원을 어떻게 투입해야 하는지에 대한 고민이다.

부하와 시스템 성능에 대한 양적 기술을 통해 애플리케이션에 특화된 확장 전략을 세울 수 있다.

#### 부하 기술하기: 트위터 예시

**적합한 부하 매개변수**를 선택해 부하를 기술한다. 예를 들면 초당 요청 수, DB의 읽기/쓰기 비율, 동시 활성 사용자, 캐시 적중률 등이다.

- 예시 - 트위터의 트윗 작성, 홈 타임라인 조회
	- 트윗 작성 : 평균 초당 4.6k 요청 / 피크 타임 초당 12k 이상 요청
	- 홈 타임라인 (트윗 조회) : 초당 300k 요청
- 위 기능을 구현하는 두 가지 방식
	- 구현 A. 트윗을 작성하면 전역 컬렉션에 새 트윗을 삽입하고, 타임라인 조회 요청이 오면 사용자가 팔로우하는 사람 목록과 이 사람들의 모든 트윗을 조인하여 반환한다.
	- 구현 B. 개별 사용자의 홈 타임라인 캐시를 유지한다. 트윗을 작성하면 팔로워들의 각 타임라인 캐시에 새 트윗을 삽입하고, 타임라인 조회 요청이 오면 캐시에서 트윗을 읽어 반환한다.

트윗 작성보다 조회 요청량이 훨씬 많기 때문에, 일반적으로 B 방식이 잘 작동한다.

B 방식의 단점은 읽기 시점에 적은 일을 하는 대신, 쓰기 시점에 많은 부가 작업을 필요로 한다는 점이다. 평균적인 팔로워 수가 75명이라고 할 때, 초당 4.6k의 트윗 작성 요청에 의해 345k건의 쓰기 작업이 발생한다. 합리적이라고 판단할 수 있지만 여기에는 평균의 함정이 존재하는데, 일론 머스크의 경우 2억명이 넘는 팔로워를 보유하고 있다. 하나의 트윗 작성이 2억건의 쓰기 작업을 필요로 한다면, 팔로워에게 트윗을 적시에 전달하지 못하는 문제가 발생할 수 있다. (그래서 트위터는 대부분의 사용자에 대해 B 방식을 사용하는 반면, 유명인과 같이 팔로워가 많은 소수의 사용자에 대해 A 방식을 부분적으로 결합했다.)

트위터 사례에서 사용자당 팔로워 분포는 확장성을 논의하기 위한 핵심 부하 매개변수가 된다. **애플리케이션 특성에 따라 적합한 매개변수를 선택해 부하를 기술해야 한다.**

#### 성능 기술하기

- 부하 매개변수를 증가시키고 시스템 자원을 변경하지 않으면, 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 시스템 성능을 유지하려면 시스템 자원을 어떻게 늘려야 할까?

일단 시스템 부하를 기술했다면, 위 질문에 답하기 위해 시스템 성능을 기술해야 한다. 온라인 서비스에서는 보통 **응답 시간**(클라이언트 관점에서 요청을 보내고 응답을 받는 사이의 시간)에 관심을 갖는다.

응답 시간은 동일한 요청이라도 매번 다르기 때문에, 단일 숫자가 아닌 분포로 생각해야 한다. 일반적으로 산술 평균치를 따지지만, 평균은 얼마나 많은 사용자가 지연을 경험했는지 알려주지 않으므로 **백분위**를 보는 것이 좋다.

- p50 : p50은 50분위, 즉 중앙값을 의미한다. 사용자가 보통 얼마나 기다려야 하는지 알고 싶은 경우 사용한다.
- 상위 백분위 값 (꼬리 지연 시간) : 응답 시간이 Outlying하게 높은 경우를 알아보기 위해 사용한다. p95, p99, p999 정도를 사용하는 것이 일반적이다.

소수의 사용자라도 꼬리 지연 시간은 중요하며, 아마존은 응답 시간 요구사항을 p999로 기술한다. 아마존은 응답 시간이 100ms 증가하면 판매랑이 1% 줄어드는 현상을 관찰했다. 반면 p9999의 응답 시간까지는 최적화하지 않는데, 이익 대비 비용이 너무 크다고 여기기 때문이다.

요청을 처리하기 위해 여러 개의 백엔드 호출이 필요한 경우, 단 하나의 느린 백엔드 요청이 최종 사용자 요청을 느리게 할 수 있다. 병렬로 요청하더라도, 가장 느린 백엔드 요청이 완료될 때까지 기다려야 하기 때문이다. 이를 꼬리 지연 증폭이라고 한다.

#### 부하 대응 접근 방식

- Scaling Up (Vertical Scaling) : 더 강력한 장비로 이동
- Scaling Out (Horizontal Scaling) : 다수의 장비에 부하를 분산
- 탄력적인 시스템 : 부하 증가를 감지했을 때 컴퓨팅 자원을 자동으로 추가할 수 있다.
- 범용적이고 모든 상황에 맞는 아키텍처는 없으며, 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화되어 있다. 특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 애플리케이션의 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정, 즉 부하 매개변수에 가정을 두고 있다. 잘못된 가정을 기반으로 설계하는 경우, 확장에 대한 효과를 얻지 못할 수 있다.

### 유지보수성

> 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.

용이한 유지보수를 위한 세 가지 설계 원칙은 다음과 같다.

- 운용성 - **편리한 운영**
	- 자동화할 수 있는 측면은 자동화하고, 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력할 수 있도록 한다.
	- 좋은 소프트웨어라도 잘못 운영할 경우 작동을 신뢰할 수 없다.
- 단순성 - **소프트웨어의 복잡도 낮추기**
	- 복잡도를 낮춰 유지보수성을 높여야 한다. 높은 복잡도의 예시로는 상태 공간의 급증, 강한 커플링, 복잡한 의존성, 일관성 없는 네이밍, 성능 문제 해결을 위한 해킹, 임시방편으로 문제를 해결한 특수 사례 등이 있다.
	- 복잡도가 높은 소프트웨어는 개발 작업 진행을 늦추고 유지보수 비용을 증가시킨다.
	- 개발자가 시스템을 이해하고 추론하기 어려워지기 때문에 변경에 의한 버그가 발생할 위험이 증가한다.
	- 우발적 복잡도를 줄이기 위해 좋은 추상화가 필요하다. 우발적 복잡도란 필수적 복잡도(제품의 사용자 입장에서 바라본 문제 그 자체)를 벗어나 성능 이슈 등 주로 개발팀이 마주하게 되는, 구현에서만 발생하는 문제를 말한다.
- 발전성 - **변경을 쉽게**
	- 끊임없이 변화하는 요구사항에 따라 데이터 시스템을 쉽게 변경할 수 있도록 해야 한다.
	- 간단하고 이해하기 쉬운 시스템, 그리고 추상화

### Reference

- 마틴 클레프만, 데이터 중심 애플리케이션 설계